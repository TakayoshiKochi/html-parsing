};
</pre>

  <p><a href=/demos/workers/stocks/page.html>View this example online</a>.</p>

  <h5 id=module-worker-example>10.1.2.3 Using a JavaScript module as a worker<a href=#module-worker-example class=self-link></a></h5>

  <p><i>This section is non-normative.</i></p>

  <p>All of our examples so far show workers that run <a href=#classic-script id=module-worker-example:classic-script>classic
  scripts</a>. Workers can instead be instantiated using <a href=#module-script id=module-worker-example:module-script>module
  scripts</a>, which have the usual benefits: the ability to use the JavaScript
  <code>import</code> statement to import other modules; strict mode by default; and
  top-level declarations not polluting the worker's global scope.</p>

  <p>Note that such module-based workers follow different restrictions regarding cross-origin
  content, compared to classic workers. Unlike classic workers, module workers can be instantiated
  using a cross-origin script, as long as that script is exposed using the <a id=module-worker-example:cors-protocol href=https://fetch.spec.whatwg.org/#http-cors-protocol data-x-internal=cors-protocol>CORS
  protocol</a>. Additionally, the <code id=module-worker-example:dom-workerglobalscope-importscripts><a href=#dom-workerglobalscope-importscripts>importScripts()</a></code> method will automatically fail
  inside module workers; the JavaScript <code>import</code> statement is generally a
  better choice.</p>

  <p>In this example, the main document uses a worker to do off-main-thread image manipulation.
  It imports the filters used from another module.</p>

  <p>The main page is as follows:</p>

  <pre>&lt;!DOCTYPE html>
&lt;meta charset="utf-8">
&lt;title>Worker example: image decoding&lt;/title>

&lt;label>
  Type an image URL to decode
  &lt;input type="url" id="image-url" list="image-list">
  &lt;datalist id="image-list">
    &lt;option value="https://html.spec.whatwg.org/images/drawImage.png">
    &lt;option value="https://html.spec.whatwg.org/images/robots.jpeg">
    &lt;option value="https://html.spec.whatwg.org/images/arcTo2.png">
  &lt;/datalist>
&lt;/label>

&lt;label>
  Choose a filter to apply
  &lt;select id="filter">
    &lt;option value="none">none&lt;/option>
    &lt;option value="grayscale">grayscale&lt;/option>
    &lt;option value="brighten">brighten by 20%&lt;/option>
  &lt;/select>
&lt;/label>

&lt;script type="module">
  const worker = new Worker("worker.js", { type: "module" });
  worker.onmessage = receiveFromWorker;

  const url = document.querySelector("#image-url");
  const filter = document.querySelector("#filter");
  const output = document.querySelector("#output");

  url.oninput = updateImage;
  filter.oninput = sendToWorker;

  let imageData, context;

  function updateImage() {
    const img = new Image();
    img.src = url.value;

    img.onload = () => {
      output.innerHTML = "";

      const canvas = document.createElement("canvas");
      canvas.width = img.width;
      canvas.height = img.height;

      context = canvas.getContext("2d");
      context.drawImage(img, 0, 0);
      imageData = context.getImageData(0, 0, canvas.width, canvas.height);

      sendToWorker();
      output.appendChild(canvas);
    };
  }

  function sendToWorker() {
    worker.postMessage({ imageData, filter: filter.value });
  }

  function receiveFromWorker(e) {
    context.putImageData(e.data, 0, 0);
  }
&lt;/script>
</pre>

  <p>The worker file is then:</p>

  <pre>import * as filters from "./filters.js";

self.onmessage = e => {
  const { imageData, filter } = e.data;
  filters[filter](imageData);
  self.postMessage(imageData, [imageData.data.buffer]);
};
</pre>

  <p>Which imports the file <code>filters.js</code>:</p>

  <pre>export function none() {}

export function grayscale({ data: d }) {
  for (let i = 0; i &lt; d.length; i += 4) {
    const [r, g, b] = [d[i], d[i + 1], d[i + 2]];

    // CIE luminance for the RGB
    // The human eye is bad at seeing red and blue, so we de-emphasize them.
    d[i] = d[i + 1] = d[i + 2] = 0.2126 * r + 0.7152 * g + 0.0722 * b;
  }
};

export function brighten({ data: d }) {
  for (let i = 0; i &lt; d.length; ++i) {
    d[i] *= 1.2;
  }
};
</pre>

  <p><a href=/demos/workers/modules/page.html>View this example online</a>.</p>


  <h5 id=shared-workers-introduction>10.1.2.4 Shared workers introduction<a href=#shared-workers-introduction class=self-link></a></h5><div class=status><input onclick=toggleStatus(this) value=â‹° type=button><p class=support><strong>Support:</strong> sharedworkers<span class="and_chr no"><span>Chrome for Android</span> <span>None</span></span><span class="chrome yes"><span>Chrome</span> <span>4+</span></span><span class="ios_saf no"><span>iOS Safari</span> <span>None</span></span><span class="and_uc yes"><span>UC Browser for Android</span> <span>11+</span></span><span class="firefox yes"><span>Firefox</span> <span>29+</span></span><span class="ie no"><span>IE</span> <span>None</span></span><span class="samsung yes"><span>Samsung Internet</span> <span>4+</span></span><span class="op_mini no"><span>Opera Mini</span> <span>None</span></span><span class="android no"><span>Android Browser</span> <span>None</span></span><span class="safari no"><span>Safari</span> <span>None</span></span><span class="edge no"><span>Edge</span> <span>None</span></span><span class="opera yes"><span>Opera</span> <span>10.6+</span></span><p class=caniuse>Source: <a href="http://caniuse.com/#feat=sharedworkers">caniuse.com</a></div>

  <p><i>This section is non-normative.</i></p>

  <p>This section introduces shared workers using a Hello World example. Shared workers use slightly
  different APIs, since each worker can have multiple connections.</p>

  <p>This first example shows how you connect to a worker and how a worker can send a message back
  to the page when it connects to it. Received messages are displayed in a log.</p>

  <p>Here is the HTML page:</p>

  <pre>&lt;!DOCTYPE HTML>
&lt;meta charset="utf-8">
&lt;title>Shared workers: demo 1&lt;/title>
&lt;pre id="log">Log:&lt;/pre>
&lt;script>
  var worker = new SharedWorker('test.js');
  var log = document.getElementById('log');
  worker.port.onmessage = function(e) { // note: not worker.onmessage!
    log.textContent += '\n' + e.data;
  }
&lt;/script>
</pre>

  <p>Here is the JavaScript worker:</p>

  <pre>onconnect = function(e) {
  var port = e.ports[0];
  port.postMessage('Hello World!');
}
</pre>

  <p><a href=/demos/workers/shared/001/test.html>View this example online</a>.</p>

  <hr>

  <p>This second example extends the first one by changing two things: first, messages are received
  using <code>addEventListener()</code> instead of an <a href=#event-handler-idl-attributes id=shared-workers-introduction:event-handler-idl-attributes>event handler IDL attribute</a>, and second, a message is sent <em>to</em> the
  worker, causing the worker to send another message in return. Received messages are again
  displayed in a log.</p>

  <p>Here is the HTML page:</p>

  <pre>&lt;!DOCTYPE HTML>
&lt;meta charset="utf-8">
&lt;title>Shared workers: demo 2&lt;/title>
&lt;pre id="log">Log:&lt;/pre>
&lt;script>
  var worker = new SharedWorker('test.js');
  var log = document.getElementById('log');
  worker.port.addEventListener('message', function(e) {
    log.textContent += '\n' + e.data;
  }, false);
  worker.port.start(); // note: need this when using addEventListener
  worker.port.postMessage('ping');
&lt;/script>
</pre>

  <p>Here is the JavaScript worker:</p>

  <pre>onconnect = function(e) {
  var port = e.ports[0];
  port.postMessage('Hello World!');
  port.onmessage = function(e) {
    port.postMessage('pong'); // not e.ports[0].postMessage!
    // e.target.postMessage('pong'); would work also
  }
}
</pre>

  <p><a href=/demos/workers/shared/002/test.html>View this example online</a>.</p>

  <hr>

  <p>Finally, the example is extended to show how two pages can connect to the same worker; in this
  case, the second page is merely in an <code id=shared-workers-introduction:the-iframe-element><a href=#the-iframe-element>iframe</a></code> on the first page, but the same
  principle would apply to an entirely separate page in a separate <a href=#top-level-browsing-context id=shared-workers-introduction:top-level-browsing-context>top-level browsing
  context</a>.</p>

  <p>Here is the outer HTML page:</p>

  <pre>&lt;!DOCTYPE HTML>
&lt;meta charset="utf-8">
&lt;title>Shared workers: demo 3&lt;/title>
&lt;pre id="log">Log:&lt;/pre>
&lt;script>
  var worker = new SharedWorker('test.js');
  var log = document.getElementById('log');
  worker.port.addEventListener('message', function(e) {
    log.textContent += '\n' + e.data;
  }, false);
  worker.port.start();
  worker.port.postMessage('ping');
&lt;/script>
&lt;iframe src="inner.html">&lt;/iframe>
</pre>

  <p>Here is the inner HTML page:</p>

  <pre>&lt;!DOCTYPE HTML>
&lt;meta charset="utf-8">
&lt;title>Shared workers: demo 3 inner frame&lt;/title>
&lt;pre id=log>Inner log:&lt;/pre>
&lt;script>
  var worker = new SharedWorker('test.js');
  var log = document.getElementById('log');
  worker.port.onmessage = function(e) {
   log.textContent += '\n' + e.data;
  }
&lt;/script>
</pre>

  <p>Here is the JavaScript worker:</p>

  <pre>var count = 0;
onconnect = function(e) {
  count += 1;
  var port = e.ports[0];
  port.postMessage('Hello World! You are connection #' + count);
  port.onmessage = function(e) {
    port.postMessage('pong');
  }
}
</pre>

  <p><a href=/demos/workers/shared/003/test.html>View this example online</a>.</p>


  <h5 id=shared-state-using-a-shared-worker>10.1.2.5 Shared state using a shared worker<a href=#shared-state-using-a-shared-worker class=self-link></a></h5>

  <p><i>This section is non-normative.</i></p>

  <p>In this example, multiple windows (viewers) can be opened that are all viewing the same map.
  All the windows share the same map information, with a single worker coordinating all the viewers.
  Each viewer can move around independently, but if they set any data on the map, all the viewers
  are updated.</p>

  <p>The main page isn't interesting, it merely provides a way to open the viewers:</p>

  <pre>&lt;!DOCTYPE HTML>
&lt;html>
 &lt;head>
  &lt;meta charset="utf-8">
  &lt;title>Workers example: Multiviewer&lt;/title>
  &lt;script>
   function openViewer() {
     window.open('viewer.html');
   }
  &lt;/script>
 &lt;/head>
 &lt;body>
  &lt;p>&lt;button type=button onclick="openViewer()">Open a new
  viewer&lt;/button>&lt;/p>
  &lt;p>Each viewer opens in a new window. You can have as many viewers
  as you like, they all view the same data.&lt;/p>
 &lt;/body>
&lt;/html>
</pre>

  <p>The viewer is more involved:</p>

  <pre>&lt;!DOCTYPE HTML>
&lt;html>
 &lt;head>
  &lt;meta charset="utf-8">
  &lt;title>Workers example: Multiviewer viewer&lt;/title>
  &lt;script>
   var worker = new SharedWorker('worker.js', 'core');

   // CONFIGURATION
   function configure(event) {
     if (event.data.substr(0, 4) != 'cfg ') return;
     var name = event.data.substr(4).split(' ', 1)[0];
     // update display to mention our name is name
     document.getElementsByTagName('h1')[0].textContent += ' ' + name;
     // no longer need this listener
     worker.port.removeEventListener('message', configure, false);
   }
   worker.port.addEventListener('message', configure, false);

   // MAP
   function paintMap(event) {
     if (event.data.substr(0, 4) != 'map ') return;
     var data = event.data.substr(4).split(',');
     // display tiles data[0] .. data[8]
     var canvas = document.getElementById('map');
     var context = canvas.getContext('2d');
     for (var y = 0; y &lt; 3; y += 1) {
       for (var x = 0; x &lt; 3; x += 1) {
         var tile = data[y * 3 + x];
         if (tile == '0')
           context.fillStyle = 'green';
         else
           context.fillStyle = 'maroon';
         context.fillRect(x * 50, y * 50, 50, 50);
       }
     }
   }
   worker.port.addEventListener('message', paintMap, false);

   // PUBLIC CHAT
   function updatePublicChat(event) {
     if (event.data.substr(0, 4) != 'txt ') return;
     var name = event.data.substr(4).split(' ', 1)[0];
     var message = event.data.substr(4 + name.length + 1);
     // display "&lt;name> message" in public chat
     var public = document.getElementById('public');
     var p = document.createElement('p');
     var n = document.createElement('button');
     n.textContent = '&lt;' + name + '> ';
     n.onclick = function () { worker.port.postMessage('msg ' + name); };
     p.appendChild(n);
     var m = document.createElement('span');
     m.textContent = message;
     p.appendChild(m);
     public.appendChild(p);
   }
   worker.port.addEventListener('message', updatePublicChat, false);

   // PRIVATE CHAT
   function startPrivateChat(event) {
     if (event.data.substr(0, 4) != 'msg ') return;
     var name = event.data.substr(4).split(' ', 1)[0];
     var port = event.ports[0];
     // display a private chat UI
     var ul = document.getElementById('private');
     var li = document.createElement('li');
     var h3 = document.createElement('h3');
     h3.textContent = 'Private chat with ' + name;
     li.appendChild(h3);
     var div = document.createElement('div');
     var addMessage = function(name, message) {
       var p = document.createElement('p');
       var n = document.createElement('strong');
       n.textContent = '&lt;' + name + '> ';
       p.appendChild(n);
       var t = document.createElement('span');
       t.textContent = message;
       p.appendChild(t);
       div.appendChild(p);
     };
     port.onmessage = function (event) {
       addMessage(name, event.data);
     };
     li.appendChild(div);
     var form = document.createElement('form');
     var p = document.createElement('p');
     var input = document.createElement('input');
     input.size = 50;
     p.appendChild(input);
     p.appendChild(document.createTextNode(' '));
     var button = document.createElement('button');
     button.textContent = 'Post';
     p.appendChild(button);
     form.onsubmit = function () {
       port.postMessage(input.value);
       addMessage('me', input.value);
       input.value = '';
       return false;
     };
     form.appendChild(p);
     li.appendChild(form);
     ul.appendChild(li);
   }
   worker.port.addEventListener('message', startPrivateChat, false);

   worker.port.start();
  &lt;/script>
 &lt;/head>
 &lt;body>
  &lt;h1>Viewer&lt;/h1>
  &lt;h2>Map&lt;/h2>
  &lt;p>&lt;canvas id="map" height=150 width=150>&lt;/canvas>&lt;/p>
  &lt;p>
   &lt;button type=button onclick="worker.port.postMessage('mov left')">Left&lt;/button>
   &lt;button type=button onclick="worker.port.postMessage('mov up')">Up&lt;/button>
   &lt;button type=button onclick="worker.port.postMessage('mov down')">Down&lt;/button>
   &lt;button type=button onclick="worker.port.postMessage('mov right')">Right&lt;/button>
   &lt;button type=button onclick="worker.port.postMessage('set 0')">Set 0&lt;/button>
   &lt;button type=button onclick="worker.port.postMessage('set 1')">Set 1&lt;/button>
  &lt;/p>
  &lt;h2>Public Chat&lt;/h2>
  &lt;div id="public">&lt;/div>
  &lt;form onsubmit="worker.port.postMessage('txt ' + message.value); message.value = ''; return false;">
   &lt;p>
    &lt;input type="text" name="message" size="50">
    &lt;button>Post&lt;/button>
   &lt;/p>
  &lt;/form>
  &lt;h2>Private Chat&lt;/h2>
  &lt;ul id="private">&lt;/ul>
 &lt;/body>
&lt;/html>
</pre>

  <p>There are several key things worth noting about the way the viewer is written.</p>

  <p><strong>Multiple listeners</strong>. Instead of a single message processing function, the code
  here attaches multiple event listeners, each one performing a quick check to see if it is relevant
  for the message. In this example it doesn't make much difference, but if multiple authors wanted
  to collaborate using a single port to communicate with a worker, it would allow for independent
  code instead of changes having to all be made to a single event handling function.</p>

  <p>Registering event listeners in this way also allows you to unregister specific listeners when
  you are done with them, as is done with the <code>configure()</code> method in this
  example.</p>

  <p>Finally, the worker:</p>

  <pre>var nextName = 0;
function getNextName() {
  // this could use more friendly names
  // but for now just return a number
  return nextName++;
}

var map = [
 [0, 0, 0, 0, 0, 0, 0],
 [1, 1, 0, 1, 0, 1, 1],
 [0, 1, 0, 1, 0, 0, 0],
 [0, 1, 0, 1, 0, 1, 1],
 [0, 0, 0, 1, 0, 0, 0],
 [1, 0, 0, 1, 1, 1, 1],
 [1, 1, 0, 1, 1, 0, 1],
];

function wrapX(x) {
  if (x &lt; 0) return wrapX(x + map[0].length);
  if (x >= map[0].length) return wrapX(x - map[0].length);
  return x;
}

function wrapY(y) {
  if (y &lt; 0) return wrapY(y + map.length);
  if (y >= map[0].length) return wrapY(y - map.length);
  return y;
}

function wrap(val, min, max) {
  if (val &lt; min)
    return val + (max-min)+1;
  if (val > max)
    return val - (max-min)-1;
  return val;
}

function sendMapData(viewer) {
  var data = '';
  for (var y = viewer.y-1; y &lt;= viewer.y+1; y += 1) {
    for (var x = viewer.x-1; x &lt;= viewer.x+1; x += 1) {
      if (data != '')
        data += ',';
      data += map[wrap(y, 0, map[0].length-1)][wrap(x, 0, map.length-1)];
    }
  }
  viewer.port.postMessage('map ' + data);
}

var viewers = {};
onconnect = function (event) {
  var name = getNextName();
  event.ports[0]._data = { port: event.ports[0], name: name, x: 0, y: 0, };
  viewers[name] = event.ports[0]._data;
  event.ports[0].postMessage('cfg ' + name);
  event.ports[0].onmessage = getMessage;
  sendMapData(event.ports[0]._data);
};

function getMessage(event) {
  switch (event.data.substr(0, 4)) {
    case 'mov ':
      var direction = event.data.substr(4);
      var dx = 0;
      var dy = 0;
      switch (direction) {
        case 'up': dy = -1; break;
        case 'down': dy = 1; break;
        case 'left': dx = -1; break;
        case 'right': dx = 1; break;
      }
      event.target._data.x = wrapX(event.target._data.x + dx);
      event.target._data.y = wrapY(event.target._data.y + dy);
      sendMapData(event.target._data);
      break;
    case 'set ':
      var value = event.data.substr(4);
      map[event.target._data.y][event.target._data.x] = value;
      for (var viewer in viewers)
        sendMapData(viewers[viewer]);
      break;
    case 'txt ':
      var name = event.target._data.name;
      var message = event.data.substr(4);
      for (var viewer in viewers)
        viewers[viewer].port.postMessage('txt ' + name + ' ' + message);
      break;
    case 'msg ':
      var party1 = event.target._data;
      var party2 = viewers[event.data.substr(4).split(' ', 1)[0]];
      if (party2) {
        var channel = new MessageChannel();
        party1.port.postMessage('msg ' + party2.name, [channel.port1]);
        party2.port.postMessage('msg ' + party1.name, [channel.port2]);
      }
      break;
  }
}
</pre>

  <p><strong>Connecting to multiple pages</strong>. The script uses the <code id=shared-state-using-a-shared-worker:handler-sharedworkerglobalscope-onconnect><a href=#handler-sharedworkerglobalscope-onconnect>onconnect</a></code> event listener to listen for
  multiple connections.</p>

  <p><strong>Direct channels</strong>. When the worker receives a "msg" message from one viewer
  naming another viewer, it sets up a direct connection between the two, so that the two viewers can
  communicate directly without the worker having to proxy all the messages.</p>

  <p><a href=/demos/workers/multiviewer/page.html>View this example online</a>.</p>


  <h5 id=delegation>10.1.2.6 Delegation<a href=#delegation class=self-link></a></h5>

  <p><i>This section is non-normative.</i></p>

  <p>With multicore CPUs becoming prevalent, one way to obtain better performance is to split
  computationally expensive tasks amongst multiple workers. In this example, a computationally
  expensive task that is to be performed for every number from 1 to 10,000,000 is farmed out to ten
  subworkers.</p>

  <p>The main page is as follows, it just reports the result:</p>

  <pre>&lt;!DOCTYPE HTML>
&lt;html>
 &lt;head>
  &lt;meta charset="utf-8">
  &lt;title>Worker example: Multicore computation&lt;/title>
 &lt;/head>
 &lt;body>
  &lt;p>Result: &lt;output id="result">&lt;/output>&lt;/p>
  &lt;script>
   var worker = new Worker('worker.js');
   worker.onmessage = function (event) {
     document.getElementById('result').textContent = event.data;
   };
  &lt;/script>
 &lt;/body>
&lt;/html>
</pre>

  <p>The worker itself is as follows:</p>

  <pre>// settings
var num_workers = 10;
var items_per_worker = 1000000;

// start the workers
var result = 0;
var pending_workers = num_workers;
for (var i = 0; i &lt; num_workers; i += 1) {
  var worker = new Worker('core.js');
  worker.postMessage(i * items_per_worker);
  worker.postMessage((i+1) * items_per_worker);
  worker.onmessage = storeResult;
}

// handle the results
function storeResult(event) {
  result += 1*event.data;
  pending_workers -= 1;
  if (pending_workers &lt;= 0)
    postMessage(result); // finished!
}
</pre>

  <p>It consists of a loop to start the subworkers, and then a handler
  that waits for all the subworkers to respond.</p>

  <p>The subworkers are implemented as follows:</p>

  <pre>var start;
onmessage = getStart;
function getStart(event) {
  start = 1*event.data;
  onmessage = getEnd;
}

var end;
function getEnd(event) {
  end = 1*event.data;
  onmessage = null;
  work();
}

function work() {
  var result = 0;
  for (var i = start; i &lt; end; i += 1) {
    // perform some complex calculation here
    result += 1;
  }
  postMessage(result);
  close();
}
</pre>

  <p>They receive two numbers in two events, perform the computation for the range of numbers thus
  specified, and then report the result back to the parent.</p>

  <p><a href=/demos/workers/multicore/page.html>View this example online</a>.</p>




  <h4 id=tutorials>10.1.3 Tutorials<a href=#tutorials class=self-link></a></h4>

  <h5 id=creating-a-dedicated-worker>10.1.3.1 Creating a dedicated worker<a href=#creating-a-dedicated-worker class=self-link></a></h5>

  <p><i>This section is non-normative.</i></p>

  <p>Creating a worker requires a URL to a JavaScript file. The <code id=creating-a-dedicated-worker:dom-worker><a href=#dom-worker>Worker()</a></code> constructor is invoked with the URL to that file as its only
  argument; a worker is then created and returned:</p>

  <pre>var worker = new Worker('helper.js');</pre>

  <p>If you want your worker script to be interpreted as a <a href=#module-script id=creating-a-dedicated-worker:module-script>module script</a> instead of
  the default <a href=#classic-script id=creating-a-dedicated-worker:classic-script>classic script</a>, you need to use a slightly different signature:</p>

  <pre>var worker = new Worker('helper.js', { type: "module" });</pre>


  <h5 id=communicating-with-a-dedicated-worker>10.1.3.2 Communicating with a dedicated worker<a href=#communicating-with-a-dedicated-worker class=self-link></a></h5>

  <p><i>This section is non-normative.</i></p>

  <p>Dedicated workers use <code id=communicating-with-a-dedicated-worker:messageport><a href=#messageport>MessagePort</a></code> objects behind the scenes, and thus support all
  the same features, such as sending structured data, transferring binary data, and transferring
  other ports.</p>

  <p>To receive messages from a dedicated worker, use the <code id=communicating-with-a-dedicated-worker:handler-worker-onmessage><a href=#handler-worker-onmessage>onmessage</a></code> <a href=#event-handler-idl-attributes id=communicating-with-a-dedicated-worker:event-handler-idl-attributes>event
  handler IDL attribute</a> on the <code id=communicating-with-a-dedicated-worker:worker><a href=#worker>Worker</a></code> object:</p>

  <pre>worker.onmessage = function (event) { ... };</pre>

  <p>You can also use the <code id=communicating-with-a-dedicated-worker:dom-eventtarget-addeventlistener><a data-x-internal=dom-eventtarget-addeventlistener href=https://dom.spec.whatwg.org/#dom-eventtarget-addeventlistener>addEventListener()</a></code>
  method.</p>

  <p class=note>The implicit <code id=communicating-with-a-dedicated-worker:messageport-2><a href=#messageport>MessagePort</a></code> used by dedicated workers has its <a href=#port-message-queue id=communicating-with-a-dedicated-worker:port-message-queue>port
  message queue</a> implicitly enabled when it is created, so there is no equivalent to the
  <code id=communicating-with-a-dedicated-worker:messageport-3><a href=#messageport>MessagePort</a></code> interface's <code id=communicating-with-a-dedicated-worker:dom-messageport-start><a href=#dom-messageport-start>start()</a></code> method on
  the <code id=communicating-with-a-dedicated-worker:worker-2><a href=#worker>Worker</a></code> interface.</p>

  <p>To <em>send</em> data to a worker, use the <code id=communicating-with-a-dedicated-worker:dom-worker-postmessage><a href=#dom-worker-postmessage>postMessage()</a></code> method. Structured data can be sent over this
  communication channel. To send <code id=communicating-with-a-dedicated-worker:idl-arraybuffer><a data-x-internal=idl-arraybuffer href=https://heycam.github.io/webidl/#idl-ArrayBuffer>ArrayBuffer</a></code> objects
  efficiently (by transferring them rather than cloning them), list them in an array in the second
  argument.</p>

  <pre>worker.postMessage({
  operation: 'find-edges',
  input: buffer, // an ArrayBuffer object
  threshold: 0.6,
}, [buffer]);</pre>

  <p>To receive a message inside the worker, the <code id=communicating-with-a-dedicated-worker:handler-dedicatedworkerglobalscope-onmessage><a href=#handler-dedicatedworkerglobalscope-onmessage>onmessage</a></code> <a href=#event-handler-idl-attributes id=communicating-with-a-dedicated-worker:event-handler-idl-attributes-2>event handler IDL attribute</a> is used.</p>

  <pre>onmessage = function (event) { ... };</pre>

  <p>You can again also use the <code id=communicating-with-a-dedicated-worker:dom-eventtarget-addeventlistener-2><a data-x-internal=dom-eventtarget-addeventlistener href=https://dom.spec.whatwg.org/#dom-eventtarget-addeventlistener>addEventListener()</a></code> method.</p>

  <p>In either case, the data is provided in the event object's <code id=communicating-with-a-dedicated-worker:dom-messageevent-data><a href=#dom-messageevent-data>data</a></code> attribute.</p>

  <p>To send messages back, you again use <code id=communicating-with-a-dedicated-worker:dom-dedicatedworkerglobalscope-postmessage><a href=#dom-dedicatedworkerglobalscope-postmessage>postMessage()</a></code>. It supports the
  structured data in the same manner.</p>

  <pre>postMessage(event.data.input, [event.data.input]); // transfer the buffer back</pre>


  <h5 id=shared-workers data-dfn-type=dfn data-lt="shared worker" data-export="">10.1.3.3 Shared workers<a href=#shared-workers class=self-link></a></h5>

  <p><i>This section is non-normative.</i></p>

  <p>Shared workers are identified by the URL of the script used to create it, optionally with an
  explicit name. The name allows multiple instances of a particular shared worker to be started.</p>

  <p>Shared workers are scoped by <a href=#concept-origin id=shared-workers:concept-origin>origin</a>. Two different sites using the same names will
  not collide. However, if a page tries to use the same shared worker name as another page on the
  same site, but with a different script URL, it will fail.</p>

  <p>Creating shared workers is done using the <code id=shared-workers:dom-sharedworker><a href=#dom-sharedworker>SharedWorker()</a></code>
  constructor. This constructor takes the URL to the script to use for its first argument, and the
  name of the worker, if any, as the second argument.</p>

  <pre>var worker = new SharedWorker('service.js');</pre>

  <p>Communicating with shared workers is done with explicit <code id=shared-workers:messageport><a href=#messageport>MessagePort</a></code> objects. The
  object returned by the <code id=shared-workers:dom-sharedworker-2><a href=#dom-sharedworker>SharedWorker()</a></code> constructor holds a
  reference to the port on its <code id=shared-workers:dom-sharedworker-port><a href=#dom-sharedworker-port>port</a></code> attribute.</p>

  <pre>worker.port.onmessage = function (event) { ... };
worker.port.postMessage('some message');
worker.port.postMessage({ foo: 'structured', bar: ['data', 'also', 'possible']});</pre>

  <p>Inside the shared worker, new clients of the worker are announced using the <code id=shared-workers:event-workerglobalscope-connect><a href=#event-workerglobalscope-connect>connect</a></code> event. The port for the new client is
  given by the event object's <code id=shared-workers:dom-messageevent-source><a href=#dom-messageevent-source>source</a></code> attribute.</p>

  <pre>onconnect = function (event) {
  var newPort = event.source;
  // set up a listener
  newPort.onmessage = function (event) { ... };
  // send a message back to the port
  newPort.postMessage('ready!'); // can also send structured data, of course
};</pre>




  <h3 id=infrastructure-2>10.2 Infrastructure<a href=#infrastructure-2 class=self-link></a></h3>

  <p>There are two kinds of workers; dedicated workers, and shared workers. Dedicated workers, once
  created, are linked to their creator; but message ports can be used to communicate from a
  dedicated worker to multiple other browsing contexts or workers. Shared workers, on the other
  hand, are named, and once created any script running in the same <a href=#concept-origin id=infrastructure-2:concept-origin>origin</a> can obtain a
  reference to that worker and communicate with it.</p>


  <h4 id=the-global-scope>10.2.1 The global scope<a href=#the-global-scope class=self-link></a></h4>

  <p>The global scope is the "inside" of a worker.</p>

  <h5 id=the-workerglobalscope-common-interface>10.2.1.1 The <code id=the-workerglobalscope-common-interface:workerglobalscope><a href=#workerglobalscope>WorkerGlobalScope</a></code> common interface<a href=#the-workerglobalscope-common-interface class=self-link></a></h5>

  <pre class=idl>[Exposed=Worker] 
interface <dfn id=workerglobalscope>WorkerGlobalScope</dfn> : <a id=the-workerglobalscope-common-interface:eventtarget href=https://dom.spec.whatwg.org/#interface-eventtarget data-x-internal=eventtarget>EventTarget</a> {
  readonly attribute <a href=#workerglobalscope id=the-workerglobalscope-common-interface:workerglobalscope-2>WorkerGlobalScope</a> <a href=#dom-workerglobalscope-self id=the-workerglobalscope-common-interface:dom-workerglobalscope-self>self</a>;
  readonly attribute <a href=#workerlocation id=the-workerglobalscope-common-interface:workerlocation>WorkerLocation</a> <a href=#dom-workerglobalscope-location id=the-workerglobalscope-common-interface:dom-workerglobalscope-location>location</a>;
  readonly attribute <a href=#workernavigator id=the-workerglobalscope-common-interface:workernavigator>WorkerNavigator</a> <a href=#dom-worker-navigator id=the-workerglobalscope-common-interface:dom-worker-navigator>navigator</a>;
  void <a href=#dom-workerglobalscope-importscripts id=the-workerglobalscope-common-interface:dom-workerglobalscope-importscripts>importScripts</a>(USVString... urls);

  attribute <a href=#onerroreventhandler id=the-workerglobalscope-common-interface:onerroreventhandler>OnErrorEventHandler</a> <a href=#handler-workerglobalscope-onerror id=the-workerglobalscope-common-interface:handler-workerglobalscope-onerror>onerror</a>;
  attribute <a href=#eventhandler id=the-workerglobalscope-common-interface:eventhandler>EventHandler</a> <a href=#handler-workerglobalscope-onlanguagechange id=the-workerglobalscope-common-interface:handler-workerglobalscope-onlanguagechange>onlanguagechange</a>;
  attribute <a href=#eventhandler id=the-workerglobalscope-common-interface:eventhandler-2>EventHandler</a> <a href=#handler-workerglobalscope-onoffline id=the-workerglobalscope-common-interface:handler-workerglobalscope-onoffline>onoffline</a>;
  attribute <a href=#eventhandler id=the-workerglobalscope-common-interface:eventhandler-3>EventHandler</a> <a href=#handler-workerglobalscope-ononline id=the-workerglobalscope-common-interface:handler-workerglobalscope-ononline>ononline</a>;
  attribute <a href=#eventhandler id=the-workerglobalscope-common-interface:eventhandler-4>EventHandler</a> <a href=#handler-workerglobalscope-onrejectionhandled id=the-workerglobalscope-common-interface:handler-workerglobalscope-onrejectionhandled>onrejectionhandled</a>;
  attribute <a href=#eventhandler id=the-workerglobalscope-common-interface:eventhandler-5>EventHandler</a> <a href=#handler-workerglobalscope-onunhandledrejection id=the-workerglobalscope-common-interface:handler-workerglobalscope-onunhandledrejection>onunhandledrejection</a>;
};</pre>

  <p>A <code id=the-workerglobalscope-common-interface:workerglobalscope-3><a href=#workerglobalscope>WorkerGlobalScope</a></code> object has an associated <dfn data-dfn-for=WorkerGlobalScope id=concept-workerglobalscope-type data-export="">type</dfn> ("<code>classic</code>" or "<code>module</code>"). It is set during creation.

  <p>A <code id=the-workerglobalscope-common-interface:workerglobalscope-4><a href=#workerglobalscope>WorkerGlobalScope</a></code> object has an associated <dfn data-dfn-for=WorkerGlobalScope id=concept-workerglobalscope-url data-export="">url</dfn> (null or a
  <a id=the-workerglobalscope-common-interface:url href=https://url.spec.whatwg.org/#concept-url data-x-internal=url>URL</a>). It is initially null.

  <p>A <code id=the-workerglobalscope-common-interface:workerglobalscope-5><a href=#workerglobalscope>WorkerGlobalScope</a></code> object has an associated <dfn data-dfn-for=WorkerGlobalScope id=concept-workerglobalscope-https-state data-export="">HTTPS state</dfn>
  (an <a id=the-workerglobalscope-common-interface:https-state-value href=https://fetch.spec.whatwg.org/#concept-https-state-value data-x-internal=https-state-value>HTTPS state value</a>). It is initially "<code>none</code>".

  <p>A <code id=the-workerglobalscope-common-interface:workerglobalscope-6><a href=#workerglobalscope>WorkerGlobalScope</a></code> object has an associated <dfn data-dfn-for=WorkerGlobalScope id=concept-workerglobalscope-referrer-policy data-export="">referrer
  policy</dfn> (a <a id=the-workerglobalscope-common-interface:referrer-policy href=https://w3c.github.io/webappsec-referrer-policy/#referrer-policy data-x-internal=referrer-policy>referrer policy</a>). It is initially the empty string.

  <p>A <code id=the-workerglobalscope-common-interface:workerglobalscope-7><a href=#workerglobalscope>WorkerGlobalScope</a></code> object has an associated <dfn data-dfn-for=WorkerGlobalScope id=concept-workerglobalscope-csp-list data-export="">CSP list</dfn>. It is
  initially an empty list.

  <p>A <code id=the-workerglobalscope-common-interface:workerglobalscope-8><a href=#workerglobalscope>WorkerGlobalScope</a></code> object has an associated <dfn data-dfn-for=WorkerGlobalScope id=concept-workerglobalscope-module-map data-export="">module map</dfn>.
  It is a <a href=#module-map id=the-workerglobalscope-common-interface:module-map>module map</a>, initially empty.</p>

  <dl class=domintro><dt><var>workerGlobal</var> . <code id=the-workerglobalscope-common-interface:dom-workerglobalscope-self-2><a href=#dom-workerglobalscope-self>self</a></code><dd>Returns <var>workerGlobal</var>.<dt><var>workerGlobal</var> . <code id=the-workerglobalscope-common-interface:dom-workerglobalscope-location-2><a href=#dom-workerglobalscope-location>location</a></code><dd>Returns <var>workerGlobal</var>'s <code id=the-workerglobalscope-common-interface:workerlocation-2><a href=#workerlocation>WorkerLocation</a></code> object.<dt><var>workerGlobal</var> . <code id=the-workerglobalscope-common-interface:dom-worker-navigator-2><a href=#dom-worker-navigator>navigator</a></code><dd>Returns <var>workerGlobal</var>'s <code id=the-workerglobalscope-common-interface:workernavigator-2><a href=#workernavigator>WorkerNavigator</a></code> object.<dt><var>workerGlobal</var> . <code id=the-workerglobalscope-common-interface:dom-workerglobalscope-importscripts-2><a href=#dom-workerglobalscope-importscripts>importScripts</a></code>(<var>urls</var>...)<dd>Fetches each <a id=the-workerglobalscope-common-interface:url-2 href=https://url.spec.whatwg.org/#concept-url data-x-internal=url>URL</a> in <var>urls</var>, executes them one-by-one in the order they
   are passed, and then returns (or throws if something went amiss).</dl>

  

  <p>The <dfn id=dom-workerglobalscope-self><code>self</code></dfn> attribute must return the
  <code id=the-workerglobalscope-common-interface:workerglobalscope-9><a href=#workerglobalscope>WorkerGlobalScope</a></code> object itself.</p>

  <p>The <dfn id=dom-workerglobalscope-location><code>location</code></dfn> attribute must
  return the <code id=the-workerglobalscope-common-interface:workerlocation-3><a href=#workerlocation>WorkerLocation</a></code> object whose associated <a href=#concept-workerlocation-workerglobalscope id=the-workerglobalscope-common-interface:concept-workerlocation-workerglobalscope><code>WorkerGlobalScope</code> object</a> is
  the <code id=the-workerglobalscope-common-interface:workerglobalscope-10><a href=#workerglobalscope>WorkerGlobalScope</a></code> object.</p>

  <p class=note>While the <code id=the-workerglobalscope-common-interface:workerlocation-4><a href=#workerlocation>WorkerLocation</a></code> object is created after the
  <code id=the-workerglobalscope-common-interface:workerglobalscope-11><a href=#workerglobalscope>WorkerGlobalScope</a></code> object, this is not problematic as it cannot be observed from
  script.</p>

  

  <hr>

  <p>The following are the <a href=#event-handlers id=the-workerglobalscope-common-interface:event-handlers>event handlers</a> (and their corresponding <a href=#event-handler-event-type id=the-workerglobalscope-common-interface:event-handler-event-type>event handler event types</a>) that must be supported, as <a href=#event-handler-idl-attributes id=the-workerglobalscope-common-interface:event-handler-idl-attributes>event handler IDL attributes</a>,
  by objects implementing the <code id=the-workerglobalscope-common-interface:workerglobalscope-12><a href=#workerglobalscope>WorkerGlobalScope</a></code> interface:</p>

  <table><thead><tr><th><a href=#event-handlers id=the-workerglobalscope-common-interface:event-handlers-2>Event handler</a> <th><a href=#event-handler-event-type id=the-workerglobalscope-common-interface:event-handler-event-type-2>Event handler event type</a>
   <tbody><tr><td><dfn id=handler-workerglobalscope-onerror><code>onerror</code></dfn> <td> <code id=the-workerglobalscope-common-interface:event-error><a href=#event-error>error</a></code>
    <tr><td><dfn id=handler-workerglobalscope-onlanguagechange><code>onlanguagechange</code></dfn> <td> <code id=the-workerglobalscope-common-interface:event-languagechange><a href=#event-languagechange>languagechange</a></code> 
    <tr><td><dfn id=handler-workerglobalscope-onoffline><code>onoffline</code></dfn> <td> <code id=the-workerglobalscope-common-interface:event-offline><a href=#event-offline>offline</a></code> 
    <tr><td><dfn id=handler-workerglobalscope-ononline><code>ononline</code></dfn> <td> <code id=the-workerglobalscope-common-interface:event-online><a href=#event-online>online</a></code> 
    <tr><td><dfn id=handler-workerglobalscope-onrejectionhandled><code>onrejectionhandled</code></dfn> <td> <code id=the-workerglobalscope-common-interface:event-rejectionhandled><a href=#event-rejectionhandled>rejectionhandled</a></code>
    <tr><td><dfn id=handler-workerglobalscope-onunhandledrejection><code>onunhandledrejection</code></dfn> <td> <code id=the-workerglobalscope-common-interface:event-unhandledrejection><a href=#event-unhandledrejection>unhandledrejection</a></code>
  </table>


  <h5 id=dedicated-workers-and-the-dedicatedworkerglobalscope-interface>10.2.1.2 Dedicated workers and the <code id=dedicated-workers-and-the-dedicatedworkerglobalscope-interface:dedicatedworkerglobalscope><a href=#dedicatedworkerglobalscope>DedicatedWorkerGlobalScope</a></code> interface<a href=#dedicated-workers-and-the-dedicatedworkerglobalscope-interface class=self-link></a></h5>

  <pre class=idl>[Global=(Worker,DedicatedWorker),Exposed=DedicatedWorker]
interface <dfn id=dedicatedworkerglobalscope>DedicatedWorkerGlobalScope</dfn> : <a href=#workerglobalscope id=dedicated-workers-and-the-dedicatedworkerglobalscope-interface:workerglobalscope>WorkerGlobalScope</a> {
  void <a href=#dom-dedicatedworkerglobalscope-postmessage id=dedicated-workers-and-the-dedicatedworkerglobalscope-interface:dom-dedicatedworkerglobalscope-postmessage>postMessage</a>(any message, optional sequence&lt;<a href=https://heycam.github.io/webidl/#idl-object id=dedicated-workers-and-the-dedicatedworkerglobalscope-interface:idl-object data-x-internal=idl-object>object</a>> transfer = []);

  void <a href=#dom-dedicatedworkerglobalscope-close id=dedicated-workers-and-the-dedicatedworkerglobalscope-interface:dom-dedicatedworkerglobalscope-close>close</a>();

  attribute <a href=#eventhandler id=dedicated-workers-and-the-dedicatedworkerglobalscope-interface:eventhandler>EventHandler</a> <a href=#handler-dedicatedworkerglobalscope-onmessage id=dedicated-workers-and-the-dedicatedworkerglobalscope-interface:handler-dedicatedworkerglobalscope-onmessage>onmessage</a>;
};</pre>

  <p><code id=dedicated-workers-and-the-dedicatedworkerglobalscope-interface:dedicatedworkerglobalscope-2><a href=#dedicatedworkerglobalscope>DedicatedWorkerGlobalScope</a></code> objects act as if they had an implicit
  <code id=dedicated-workers-and-the-dedicatedworkerglobalscope-interface:messageport><a href=#messageport>MessagePort</a></code> associated with them. This port is part of a channel that is set up when
  the worker is created, but it is not exposed. This object must never be garbage collected before
  the <code id=dedicated-workers-and-the-dedicatedworkerglobalscope-interface:dedicatedworkerglobalscope-3><a href=#dedicatedworkerglobalscope>DedicatedWorkerGlobalScope</a></code> object.</p>

  <p>All messages received by that port must immediately be retargeted at the
  <code id=dedicated-workers-and-the-dedicatedworkerglobalscope-interface:dedicatedworkerglobalscope-4><a href=#dedicatedworkerglobalscope>DedicatedWorkerGlobalScope</a></code> object.</p>

  <dl class=domintro><dt><var>dedicatedWorkerGlobal</var> . <code id=dedicated-workers-and-the-dedicatedworkerglobalscope-interface:dom-dedicatedworkerglobalscope-postmessage-2><a href=#dom-dedicatedworkerglobalscope-postmessage>postMessage</a></code>(<var>message</var> [,
   <var>transfer</var> ])<dd>Clones <var>message</var> and transmits it to the <code id=dedicated-workers-and-the-dedicatedworkerglobalscope-interface:worker><a href=#worker>Worker</a></code> object associated with
   <var>dedicatedWorkerGlobal</var>. <var>transfer</var> can be passed as a list of objects that are
   to be transferred rather than cloned.<dt><var>dedicatedWorkerGlobal</var> . <code id=dedicated-workers-and-the-dedicatedworkerglobalscope-interface:dom-dedicatedworkerglobalscope-close-2><a href=#dom-dedicatedworkerglobalscope-close>close</a></code>()<dd>Aborts <var>dedicatedWorkerGlobal</var>.</dl>

  <p>The <dfn id=dom-dedicatedworkerglobalscope-postmessage><code>postMessage()</code></dfn>
  method on <code id=dedicated-workers-and-the-dedicatedworkerglobalscope-interface:dedicatedworkerglobalscope-5><a href=#dedicatedworkerglobalscope>DedicatedWorkerGlobalScope</a></code> objects must act as if, when invoked, it
  immediately invoked <a href=#dom-messageport-postmessage id=dedicated-workers-and-the-dedicatedworkerglobalscope-interface:dom-messageport-postmessage>the method of the same name</a>
  on the port, with the same arguments, and returned the same return value.</p>
